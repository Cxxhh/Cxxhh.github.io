<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>FreeRTOS 基础入门：堆栈、目录结构与编程规范</title>
    <link href="/2025/12/05/freertos-basics/"/>
    <url>/2025/12/05/freertos-basics/</url>
    
    <content type="html"><![CDATA[<h1 id="FreeRTOS-基础入门"><a href="#FreeRTOS-基础入门" class="headerlink" title="FreeRTOS 基础入门"></a>FreeRTOS 基础入门</h1><p>本文整理了 FreeRTOS 学习过程中的基础知识，包括堆栈概念、FreeRTOS 的目录结构以及官方推荐的编程规范。</p><h2 id="一、RTOS-学习基础：堆与栈"><a href="#一、RTOS-学习基础：堆与栈" class="headerlink" title="一、RTOS 学习基础：堆与栈"></a>一、RTOS 学习基础：堆与栈</h2><h3 id="1-堆-Heap"><a href="#1-堆-Heap" class="headerlink" title="1. 堆 (Heap)"></a>1. 堆 (Heap)</h3><p>堆是一个由用户控制的空闲内存区域，需要手动申请和释放空间。我们通常使用 <code>malloc</code> 分配的内存（如 <code>char *p = malloc(10);</code>）就位于堆中。</p><p><strong>简单的堆分配演示：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> heap_buf[<span class="hljs-number">1024</span>]; <span class="hljs-comment">// 模拟堆内存池</span><br><span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;         <span class="hljs-comment">// 堆指针</span><br><br><span class="hljs-type">void</span> *<span class="hljs-title function_">my_malloc</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> &#123;<br>    <span class="hljs-type">int</span> old_pos = pos;         <span class="hljs-comment">// 保存当前分配起始位置</span><br>    pos = pos + size;          <span class="hljs-comment">// 更新堆指针</span><br>    <span class="hljs-keyword">return</span> &amp;heap_buf[old_pos]; <span class="hljs-comment">// 返回申请到的内存首地址</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> ch = <span class="hljs-number">65</span>; <span class="hljs-comment">// &#x27;A&#x27;</span><br>    <br>    <span class="hljs-comment">// 模拟分配堆内存</span><br>    <span class="hljs-type">char</span> *buf = (<span class="hljs-type">char</span> *)my_malloc(<span class="hljs-number">100</span>);  <span class="hljs-comment">// 分配100字节 0x000~0x063</span><br>    <span class="hljs-type">char</span> *buf2 = (<span class="hljs-type">char</span> *)my_malloc(<span class="hljs-number">100</span>); <span class="hljs-comment">// 分配100字节 0x064~0x0C7</span><br>    <br>    <span class="hljs-type">uint8_t</span> uch = <span class="hljs-number">200</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>        buf[i] = ch + i;   <span class="hljs-comment">// 往堆内存写入数据</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>        buf2[i] = uch + i; <span class="hljs-comment">// 往堆内存写入数据</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-栈-Stack"><a href="#2-栈-Stack" class="headerlink" title="2. 栈 (Stack)"></a>2. 栈 (Stack)</h3><p>栈是函数运行时使用的内存区域，由编译器自动分配和释放。栈主要用于存放：</p><ul><li>函数的参数</li><li>局部变量</li><li>函数返回地址</li></ul><p><strong>函数调用与栈的过程：</strong></p><p>当主函数调用子函数时，会将下一条指令的地址（返回地址）压入栈中，然后跳转到子函数执行。子函数执行完毕后，从栈中弹出返回地址，跳转回主函数继续执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">AFUN</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br>    <br>    <span class="hljs-comment">// 假设这条指令的地址是 0x1000</span><br>    BFUN();  <span class="hljs-comment">// ← 调用 BFUN</span><br>    <br>    <span class="hljs-comment">// 假设这条指令的地址是 0x1004 ← 这就是返回地址！</span><br>    <span class="hljs-type">int</span> c = a + b;  <span class="hljs-comment">// BFUN 返回后，继续执行这里</span><br>    <br>    <span class="hljs-comment">// 地址 0x1008</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">BFUN</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br>    <span class="hljs-comment">// ... 执行一些操作</span><br>    <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 返回到 0x1004（AFUN 中调用 BFUN 的下一条指令）</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="二、FreeRTOS-目录结构-基于-STM32F1"><a href="#二、FreeRTOS-目录结构-基于-STM32F1" class="headerlink" title="二、FreeRTOS 目录结构 (基于 STM32F1)"></a>二、FreeRTOS 目录结构 (基于 STM32F1)</h2><p>了解 FreeRTOS 的源码目录结构有助于快速上手移植和开发。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs text">FreeRTOS/<br>│<br>├── Demo/                    # 示例工程<br>│   ├── Common/              # 通用演示代码<br>│   └── CORTEX_STM32F103_Keil/ # 特定平台的演示工程<br>│<br>├── License/                 # 许可证<br>│   └── license.txt<br>│<br>├── Source/                  # 内核源码（核心部分）<br>│   ├── include/             # 头文件<br>│   ├── portable/            # 移植层文件（与硬件相关）<br>│   │   ├── [Compiler]/[Arch]/ # 对应编译器和架构的接口文件<br>│   │   └── MemMang/         # 内存管理实现 (heap_1.c ~ heap_5.c)<br>│   ├── croutine.c           # 协程（通常不常用）<br>│   ├── event_groups.c       # 事件组<br>│   ├── list.c               # 链表实现<br>│   ├── queue.c              # 队列实现<br>│   ├── stream_buffer.c      # 流缓冲区<br>│   ├── tasks.c              # 任务管理<br>│   └── timers.c             # 软件定时器<br>│<br>├── README.md<br>└── ...<br></code></pre></td></tr></table></figure><hr><h2 id="三、FreeRTOS-数据类型和编程规范"><a href="#三、FreeRTOS-数据类型和编程规范" class="headerlink" title="三、FreeRTOS 数据类型和编程规范"></a>三、FreeRTOS 数据类型和编程规范</h2><p>FreeRTOS 有一套独特的命名规范，遵循这些规范可以让代码风格与内核保持一致。</p><h3 id="1-变量命名前缀"><a href="#1-变量命名前缀" class="headerlink" title="1. 变量命名前缀"></a>1. 变量命名前缀</h3><p>变量名通常包含一个小写字母前缀，表示变量的类型。</p><table><thead><tr><th align="left">变量名前缀</th><th align="left">含义</th><th align="left">C 类型</th></tr></thead><tbody><tr><td align="left"><code>c</code></td><td align="left">Char</td><td align="left"><code>char</code></td></tr><tr><td align="left"><code>s</code></td><td align="left">Short</td><td align="left"><code>int16_t</code>, <code>short</code></td></tr><tr><td align="left"><code>l</code></td><td align="left">Long</td><td align="left"><code>int32_t</code>, <code>long</code></td></tr><tr><td align="left"><code>x</code></td><td align="left">BaseType</td><td align="left"><code>BaseType_t</code> 及非标准类型 (结构体, Handle 等)</td></tr><tr><td align="left"><code>u</code></td><td align="left">Unsigned</td><td align="left"><code>unsigned</code></td></tr><tr><td align="left"><code>p</code></td><td align="left">Pointer</td><td align="left">指针</td></tr><tr><td align="left"><code>uc</code></td><td align="left">Unsigned Char</td><td align="left"><code>uint8_t</code>, <code>unsigned char</code></td></tr><tr><td align="left"><code>pc</code></td><td align="left">Pointer to Char</td><td align="left"><code>char *</code></td></tr></tbody></table><h3 id="2-函数命名前缀"><a href="#2-函数命名前缀" class="headerlink" title="2. 函数命名前缀"></a>2. 函数命名前缀</h3><p>函数名也包含前缀，表示返回值类型和作用域。</p><table><thead><tr><th align="left">函数名前缀</th><th align="left">含义</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>prv</code></td><td align="left">Private (私有)</td><td align="left"><code>prvSetupHardware</code> (通常是 static 函数)</td></tr><tr><td align="left"><code>v</code></td><td align="left">Void (无返回值)</td><td align="left"><code>vTaskStartScheduler</code></td></tr><tr><td align="left"><code>x</code></td><td align="left">BaseType (非 void)</td><td align="left"><code>xTaskCreate</code> (返回 BaseType_t 或 Handle)</td></tr></tbody></table><h3 id="3-宏命名规范"><a href="#3-宏命名规范" class="headerlink" title="3. 宏命名规范"></a>3. 宏命名规范</h3><p>宏通常大写，前缀小写，表示宏定义所在的文件。</p><table><thead><tr><th align="left">宏的前缀</th><th align="left">含义 (定义文件)</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left"><code>port</code></td><td align="left"><code>portable.h</code> 或 <code>portmacro.h</code></td><td align="left"><code>portMAX_DELAY</code></td></tr><tr><td align="left"><code>task</code></td><td align="left"><code>task.h</code></td><td align="left"><code>taskENTER_CRITICAL()</code></td></tr><tr><td align="left"><code>pd</code></td><td align="left"><code>projdefs.h</code></td><td align="left"><code>pdTRUE</code></td></tr><tr><td align="left"><code>config</code></td><td align="left"><code>FreeRTOSConfig.h</code></td><td align="left"><code>configUSE_PREEMPTION</code></td></tr><tr><td align="left"><code>err</code></td><td align="left"><code>projdefs.h</code></td><td align="left"><code>errQUEUE_FULL</code></td></tr></tbody></table><h3 id="4-通用宏定义"><a href="#4-通用宏定义" class="headerlink" title="4. 通用宏定义"></a>4. 通用宏定义</h3><p>FreeRTOS 中常用的逻辑值宏定义：</p><table><thead><tr><th align="left">宏</th><th align="left">值</th></tr></thead><tbody><tr><td align="left"><code>pdTRUE</code></td><td align="left"><code>1</code></td></tr><tr><td align="left"><code>pdFALSE</code></td><td align="left"><code>0</code></td></tr><tr><td align="left"><code>pdPASS</code></td><td align="left"><code>1</code></td></tr><tr><td align="left"><code>pdFAIL</code></td><td align="left"><code>0</code></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>嵌入式开发</category>
      
      <category>FreeRTOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>FreeRTOS</tag>
      
      <tag>RTOS</tag>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STM32 SPI通信详解与动画演示</title>
    <link href="/2025/12/04/stm32-spi-introduction/"/>
    <url>/2025/12/04/stm32-spi-introduction/</url>
    
    <content type="html"><![CDATA[<h1 id="STM32-SPI通信详解"><a href="#STM32-SPI通信详解" class="headerlink" title="STM32 SPI通信详解"></a>STM32 SPI通信详解</h1><h2 id="一、SPI简介"><a href="#一、SPI简介" class="headerlink" title="一、SPI简介"></a>一、SPI简介</h2><p><strong>SPI（Serial Peripheral Interface）</strong> 是由Motorola公司提出的一种高速、全双工、同步的串行通信总线。它广泛应用于MCU与各种外设之间的通信，如Flash存储器、LCD显示屏、传感器、AD&#x2F;DA转换器等。</p><h3 id="SPI的主要特点"><a href="#SPI的主要特点" class="headerlink" title="SPI的主要特点"></a>SPI的主要特点</h3><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>通信方式</td><td>同步串行、全双工</td></tr><tr><td>主从模式</td><td>支持单主多从</td></tr><tr><td>通信速率</td><td>可达数十MHz</td></tr><tr><td>信号线数</td><td>4线（可简化为3线）</td></tr><tr><td>数据位宽</td><td>通常8位或16位</td></tr></tbody></table><h2 id="二、SPI信号线说明"><a href="#二、SPI信号线说明" class="headerlink" title="二、SPI信号线说明"></a>二、SPI信号线说明</h2><p>SPI总线由4根信号线组成：</p><table><thead><tr><th>信号线</th><th>全称</th><th>方向</th><th>功能说明</th></tr></thead><tbody><tr><td><strong>SCK</strong></td><td>Serial Clock</td><td>Master → Slave</td><td>时钟信号，由主机产生</td></tr><tr><td><strong>MOSI</strong></td><td>Master Out Slave In</td><td>Master → Slave</td><td>主机发送、从机接收</td></tr><tr><td><strong>MISO</strong></td><td>Master In Slave Out</td><td>Slave → Master</td><td>从机发送、主机接收</td></tr><tr><td><strong>CS&#x2F;SS</strong></td><td>Chip Select &#x2F; Slave Select</td><td>Master → Slave</td><td>片选信号，低电平有效</td></tr></tbody></table><h3 id="信号时序关系"><a href="#信号时序关系" class="headerlink" title="信号时序关系"></a>信号时序关系</h3><ul><li><strong>CS</strong>：片选信号，拉低表示选中从机，开始通信</li><li><strong>SCK</strong>：时钟信号，每个时钟周期传输1位数据</li><li><strong>MOSI&#x2F;MISO</strong>：数据在时钟边沿进行采样或切换</li></ul><h2 id="三、SPI工作模式"><a href="#三、SPI工作模式" class="headerlink" title="三、SPI工作模式"></a>三、SPI工作模式</h2><p>SPI有4种工作模式，由 <strong>CPOL（时钟极性）</strong> 和 <strong>CPHA（时钟相位）</strong> 两个参数决定：</p><table><thead><tr><th>模式</th><th>CPOL</th><th>CPHA</th><th>空闲时SCK</th><th>采样边沿</th></tr></thead><tbody><tr><td>Mode 0</td><td>0</td><td>0</td><td>低电平</td><td>上升沿采样</td></tr><tr><td>Mode 1</td><td>0</td><td>1</td><td>低电平</td><td>下降沿采样</td></tr><tr><td>Mode 2</td><td>1</td><td>0</td><td>高电平</td><td>下降沿采样</td></tr><tr><td>Mode 3</td><td>1</td><td>1</td><td>高电平</td><td>上升沿采样</td></tr></tbody></table><blockquote><p><strong>最常用的是Mode 0和Mode 3</strong>，大多数SPI外设默认支持这两种模式。</p></blockquote><h2 id="四、SPI通信动画演示"><a href="#四、SPI通信动画演示" class="headerlink" title="四、SPI通信动画演示"></a>四、SPI通信动画演示</h2><p>下面是一个交互式的SPI通信动画演示，展示了Mode 0模式下的数据传输过程：</p><div style="width: 100%; max-width: 100%; margin: 20px 0; border-radius: 12px; overflow: hidden; box-shadow: 0 8px 32px rgba(0,0,0,0.4); border: 1px solid #374151;">  <iframe     src="/demos/spi-animation.html"     style="width: 100%; height: 420px; border: none; display: block;"    allowfullscreen    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope"  ></iframe></div><p><strong>🎮 操作说明：</strong></p><ul><li>在 <strong>DATA</strong> 输入框中输入要发送的十六进制数据（如 <code>A5</code>、<code>FF</code>、<code>00</code> 等）</li><li>点击「<strong>发送</strong>」按钮开始传输动画</li><li>观察波形图中 CS、SCK、MOSI、MISO 四个信号的变化</li><li><strong>点击波形区域</strong>可添加标记线，方便分析时序</li><li>使用右下角 <strong>速度按钮</strong> 调整动画播放速度（支持0.2x~1.5x）</li></ul><h2 id="五、STM32-SPI外设特性"><a href="#五、STM32-SPI外设特性" class="headerlink" title="五、STM32 SPI外设特性"></a>五、STM32 SPI外设特性</h2><p>STM32系列MCU内置硬件SPI控制器，主要特性包括：</p><h3 id="硬件特性"><a href="#硬件特性" class="headerlink" title="硬件特性"></a>硬件特性</h3><ul><li>支持主机&#x2F;从机模式</li><li>支持全双工、半双工、单工通信</li><li>数据帧格式：8位或16位</li><li>波特率预分频器：2~256分频</li><li>MSB&#x2F;LSB先行可配置</li><li>支持DMA传输</li><li>支持中断和轮询方式</li></ul><h3 id="时钟配置"><a href="#时钟配置" class="headerlink" title="时钟配置"></a>时钟配置</h3><p>SPI时钟由APB总线时钟分频得到：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">SPI_CLK</span> = APB_CLK / Prescaler<br></code></pre></td></tr></table></figure><p>分频系数可选：2, 4, 8, 16, 32, 64, 128, 256</p><h2 id="六、STM32-HAL库SPI配置示例"><a href="#六、STM32-HAL库SPI配置示例" class="headerlink" title="六、STM32 HAL库SPI配置示例"></a>六、STM32 HAL库SPI配置示例</h2><h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">SPI_HandleTypeDef hspi1;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">MX_SPI1_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    hspi1.Instance = SPI1;<br>    hspi1.Init.Mode = SPI_MODE_MASTER;           <span class="hljs-comment">// 主机模式</span><br>    hspi1.Init.Direction = SPI_DIRECTION_2LINES; <span class="hljs-comment">// 全双工</span><br>    hspi1.Init.DataSize = SPI_DATASIZE_8BIT;     <span class="hljs-comment">// 8位数据</span><br>    hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;   <span class="hljs-comment">// CPOL = 0</span><br>    hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;       <span class="hljs-comment">// CPHA = 0 (Mode 0)</span><br>    hspi1.Init.NSS = SPI_NSS_SOFT;               <span class="hljs-comment">// 软件片选</span><br>    hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;<br>    hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;      <span class="hljs-comment">// MSB先行</span><br>    hspi1.Init.TIMode = SPI_TIMODE_DISABLE;<br>    hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;<br>    <br>    HAL_SPI_Init(&amp;hspi1);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数据发送接收"><a href="#数据发送接收" class="headerlink" title="数据发送接收"></a>数据发送接收</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 发送数据</span><br><span class="hljs-type">uint8_t</span> tx_data = <span class="hljs-number">0xA5</span>;<br>HAL_SPI_Transmit(&amp;hspi1, &amp;tx_data, <span class="hljs-number">1</span>, HAL_MAX_DELAY);<br><br><span class="hljs-comment">// 接收数据</span><br><span class="hljs-type">uint8_t</span> rx_data;<br>HAL_SPI_Receive(&amp;hspi1, &amp;rx_data, <span class="hljs-number">1</span>, HAL_MAX_DELAY);<br><br><span class="hljs-comment">// 全双工收发（同时发送和接收）</span><br><span class="hljs-type">uint8_t</span> tx_buf[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0x01</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x04</span>&#125;;<br><span class="hljs-type">uint8_t</span> rx_buf[<span class="hljs-number">4</span>];<br>HAL_SPI_TransmitReceive(&amp;hspi1, tx_buf, rx_buf, <span class="hljs-number">4</span>, HAL_MAX_DELAY);<br></code></pre></td></tr></table></figure><h3 id="片选控制"><a href="#片选控制" class="headerlink" title="片选控制"></a>片选控制</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 软件控制CS引脚</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_CS_LOW()   HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_RESET)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SPI_CS_HIGH()  HAL_GPIO_WritePin(SPI_CS_GPIO_Port, SPI_CS_Pin, GPIO_PIN_SET)</span><br><br><span class="hljs-comment">// 完整的SPI读写流程</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">SPI_WriteRead</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *tx_buf, <span class="hljs-type">uint8_t</span> *rx_buf, <span class="hljs-type">uint16_t</span> len)</span><br>&#123;<br>    SPI_CS_LOW();  <span class="hljs-comment">// 拉低片选</span><br>    HAL_SPI_TransmitReceive(&amp;hspi1, tx_buf, rx_buf, len, HAL_MAX_DELAY);<br>    SPI_CS_HIGH(); <span class="hljs-comment">// 释放片选</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="七、SPI应用注意事项"><a href="#七、SPI应用注意事项" class="headerlink" title="七、SPI应用注意事项"></a>七、SPI应用注意事项</h2><h3 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h3><ol><li><strong>信号线长度</strong>：高速SPI时，信号线应尽量短，避免阻抗不匹配</li><li><strong>上拉电阻</strong>：CS线建议加上拉电阻，防止误触发</li><li><strong>去耦电容</strong>：SPI外设电源引脚需加去耦电容</li></ol><h3 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h3><ol><li><strong>模式匹配</strong>：主从设备的CPOL&#x2F;CPHA必须一致</li><li><strong>速率选择</strong>：不要超过从设备支持的最大速率</li><li><strong>时序间隔</strong>：某些器件在CS拉低后需要等待一段时间</li></ol><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><table><thead><tr><th>问题</th><th>可能原因</th><th>解决方案</th></tr></thead><tbody><tr><td>数据全0xFF</td><td>MISO线未连接或从机无响应</td><td>检查接线和从机供电</td></tr><tr><td>数据错位</td><td>时钟模式不匹配</td><td>核对CPOL&#x2F;CPHA配置</td></tr><tr><td>通信不稳定</td><td>速率过高或干扰</td><td>降低波特率，检查布线</td></tr><tr><td>只能发不能收</td><td>GPIO配置错误</td><td>检查MISO引脚配置</td></tr></tbody></table><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>SPI作为一种高速同步串行通信协议，在嵌入式系统中应用广泛。掌握SPI的工作原理和配置方法，对于嵌入式开发者来说非常重要。通过上面的动画演示，相信你对SPI的时序已经有了直观的理解。</p><h3 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h3><ul><li><a href="https://www.st.com/resource/en/user_manual/um1785-description-of-stm32f0-hal-and-lowlayer-drivers-stmicroelectronics.pdf">STM32 SPI HAL库官方文档</a></li><li><a href="https://www.nxp.com/docs/en/application-note/AN3950.pdf">SPI协议规范</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>嵌入式开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>STM32</tag>
      
      <tag>SPI</tag>
      
      <tag>通信协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式架构和代码规范</title>
    <link href="/2025/12/03/embedded-code-standards/"/>
    <url>/2025/12/03/embedded-code-standards/</url>
    
    <content type="html"><![CDATA[<h1 id="嵌入式架构和代码规范"><a href="#嵌入式架构和代码规范" class="headerlink" title="嵌入式架构和代码规范"></a>嵌入式架构和代码规范</h1><h2 id="一、通用嵌入式5层架构"><a href="#一、通用嵌入式5层架构" class="headerlink" title="一、通用嵌入式5层架构"></a>一、通用嵌入式5层架构</h2><table><thead><tr><th>层级</th><th>名称</th><th>职责</th><th>示例</th></tr></thead><tbody><tr><td><strong>L0</strong></td><td>HAL</td><td>MCU片内外设初始化与底层操作</td><td>GPIO、RCC、UART、I2C、SPI、TIM、DMA、ADC</td></tr><tr><td><strong>L1</strong></td><td>BSP</td><td>板级外挂硬件设备驱动</td><td>LCD、按键、LED、传感器、存储器、电机驱动</td></tr><tr><td><strong>L2</strong></td><td>Middlewares</td><td>第三方中间件&#x2F;协议栈</td><td>FatFs、LVGL、FreeRTOS、MQTT、Modbus</td></tr><tr><td><strong>L3</strong></td><td>Service&#x2F;Core</td><td>核心服务层</td><td>算法模块、协议解析、状态机、数据管理</td></tr><tr><td><strong>L4</strong></td><td>APP</td><td>应用逻辑层</td><td>UI交互、业务流程、任务调度、系统配置</td></tr></tbody></table><h2 id="二、各层职责详细说明"><a href="#二、各层职责详细说明" class="headerlink" title="二、各层职责详细说明"></a>二、各层职责详细说明</h2><h3 id="L0-HAL层（Hardware-Abstraction-Layer）"><a href="#L0-HAL层（Hardware-Abstraction-Layer）" class="headerlink" title="L0 - HAL层（Hardware Abstraction Layer）"></a>L0 - HAL层（Hardware Abstraction Layer）</h3><ul><li>MCU片内外设的初始化与配置</li><li>寄存器级别的底层操作封装</li><li>时钟、中断、DMA等系统资源管理</li><li>仅依赖芯片厂商提供的库或直接操作寄存器</li></ul><h3 id="L1-BSP层（Board-Support-Package）"><a href="#L1-BSP层（Board-Support-Package）" class="headerlink" title="L1 - BSP层（Board Support Package）"></a>L1 - BSP层（Board Support Package）</h3><ul><li>板级外挂硬件设备的驱动实现</li><li>每个硬件设备封装为独立模块</li><li>提供统一的设备操作接口</li><li>仅依赖HAL层</li></ul><h3 id="L2-Middlewares层（中间件层）"><a href="#L2-Middlewares层（中间件层）" class="headerlink" title="L2 - Middlewares层（中间件层）"></a>L2 - Middlewares层（中间件层）</h3><ul><li>存放第三方中间件和协议栈</li><li>文件系统、图形库、通信协议等</li><li>可依赖HAL层和BSP层</li></ul><h3 id="L3-Service-Core层（核心服务层）"><a href="#L3-Service-Core层（核心服务层）" class="headerlink" title="L3 - Service&#x2F;Core层（核心服务层）"></a>L3 - Service&#x2F;Core层（核心服务层）</h3><ul><li>业务核心算法实现</li><li>协议解析与数据处理</li><li>状态机管理</li><li>可依赖Middlewares、BSP、HAL层</li></ul><h3 id="L4-APP层（应用层）"><a href="#L4-APP层（应用层）" class="headerlink" title="L4 - APP层（应用层）"></a>L4 - APP层（应用层）</h3><ul><li>用户界面与交互逻辑</li><li>业务流程控制</li><li>系统配置管理</li><li>仅通过Service层接口访问底层功能</li></ul><h2 id="三、层间调用规则"><a href="#三、层间调用规则" class="headerlink" title="三、层间调用规则"></a>三、层间调用规则</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">APP</span> → Service/Core → Middlewares → BSP → HAL<br></code></pre></td></tr></table></figure><table><thead><tr><th>层级</th><th>可调用</th><th>禁止调用</th></tr></thead><tbody><tr><td>HAL</td><td>芯片寄存器&#x2F;厂商库</td><td>上层任何模块</td></tr><tr><td>BSP</td><td>HAL</td><td>Middlewares、Service、APP</td></tr><tr><td>Middlewares</td><td>HAL、BSP</td><td>Service、APP</td></tr><tr><td>Service</td><td>Middlewares、BSP、HAL</td><td>APP</td></tr><tr><td>APP</td><td>Service、Middlewares</td><td>尽量不直接调用BSP&#x2F;HAL</td></tr></tbody></table><h3 id="核心原则"><a href="#核心原则" class="headerlink" title="核心原则"></a>核心原则</h3><ol><li><strong>单向依赖</strong>：只允许上层调用下层，禁止下层调用上层</li><li><strong>禁止跨层</strong>：尽量避免跨层调用（特殊情况如中断回调除外）</li><li><strong>接口隔离</strong>：每层通过统一接口对外暴露功能</li><li><strong>可替换性</strong>：更换硬件只需修改HAL&#x2F;BSP层，上层代码无需改动</li></ol><h2 id="四、BSP层接口规范"><a href="#四、BSP层接口规范" class="headerlink" title="四、BSP层接口规范"></a>四、BSP层接口规范</h2><p>每个设备模块应提供统一风格的接口：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 初始化/反初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">bsp_xxx_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">bsp_xxx_deinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-comment">// 基本操作</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bsp_xxx_read</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *data, <span class="hljs-type">uint16_t</span> len)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">bsp_xxx_write</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *data, <span class="hljs-type">uint16_t</span> len)</span>;<br><br><span class="hljs-comment">// 状态查询</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">bsp_xxx_get_status</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><h2 id="五、头文件包含规则"><a href="#五、头文件包含规则" class="headerlink" title="五、头文件包含规则"></a>五、头文件包含规则</h2><table><thead><tr><th>层级</th><th>允许包含</th><th>禁止包含</th></tr></thead><tbody><tr><td>HAL</td><td>芯片厂商头文件、标准库</td><td>BSP、Middlewares、Service、APP</td></tr><tr><td>BSP</td><td>HAL层头文件</td><td>Middlewares、Service、APP</td></tr><tr><td>Middlewares</td><td>HAL、BSP头文件</td><td>Service、APP</td></tr><tr><td>Service</td><td>Middlewares、BSP、HAL头文件</td><td>APP</td></tr><tr><td>APP</td><td>Service、Middlewares头文件</td><td>尽量不直接包含BSP&#x2F;HAL</td></tr></tbody></table><h2 id="六、命名规范"><a href="#六、命名规范" class="headerlink" title="六、命名规范"></a>六、命名规范</h2><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><ul><li>HAL层：<code>hal_xxx.c/h</code>（如 <code>hal_gpio.c</code>）</li><li>BSP层：<code>bsp_xxx.c/h</code>（如 <code>bsp_lcd.c</code>）</li><li>Service层：<code>xxx_service.c/h</code> 或 <code>xxx_core.c/h</code></li><li>APP层：<code>app_xxx.c/h</code> 或 <code>screen_xxx.c/h</code></li></ul><h3 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h3><ul><li>使用小写字母和下划线分隔</li><li>前缀表明所属层级：<code>hal_</code>、<code>bsp_</code>、<code>svc_</code>、<code>app_</code></li><li>示例：<code>bsp_lcd_draw_pixel()</code>、<code>svc_data_parse()</code></li></ul><h3 id="宏定义命名"><a href="#宏定义命名" class="headerlink" title="宏定义命名"></a>宏定义命名</h3><ul><li>全部大写，下划线分隔</li><li>前缀表明所属模块</li><li>示例：<code>BSP_LCD_WIDTH</code>、<code>HAL_UART_BAUDRATE</code></li></ul><h2 id="七、类型定义规范"><a href="#七、类型定义规范" class="headerlink" title="七、类型定义规范"></a>七、类型定义规范</h2><h3 id="typedef后缀规范"><a href="#typedef后缀规范" class="headerlink" title="typedef后缀规范"></a>typedef后缀规范</h3><table><thead><tr><th>类型</th><th>后缀</th><th>示例</th></tr></thead><tbody><tr><td>结构体</td><td><code>_t</code></td><td><code>button_event_t</code></td></tr><tr><td>联合体</td><td><code>_union</code></td><td><code>data_convert_union</code></td></tr><tr><td>枚举</td><td><code>_enum</code></td><td><code>button_state_enum</code></td></tr></tbody></table><h3 id="函数指针命名"><a href="#函数指针命名" class="headerlink" title="函数指针命名"></a>函数指针命名</h3><ul><li>前缀：<code>pf_</code></li><li>示例：<code>typedef void (*pf_callback)(uint8_t data);</code></li></ul><h3 id="枚举成员命名"><a href="#枚举成员命名" class="headerlink" title="枚举成员命名"></a>枚举成员命名</h3><ul><li>全部大写，下划线分隔</li><li>示例：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    BUTTON_IDLE,<br>    BUTTON_PRESSED,<br>    BUTTON_RELEASED<br>&#125; button_state_enum;<br></code></pre></td></tr></table></figure><h2 id="八、函数命名规范"><a href="#八、函数命名规范" class="headerlink" title="八、函数命名规范"></a>八、函数命名规范</h2><h3 id="静态局部函数"><a href="#静态局部函数" class="headerlink" title="静态局部函数"></a>静态局部函数</h3><ul><li>以下划线 <code>_</code> 开头</li><li>使用小写和下划线</li><li>示例：<code>_usart_tx()</code>、<code>_parse_data()</code></li></ul><h3 id="外部接口函数"><a href="#外部接口函数" class="headerlink" title="外部接口函数"></a>外部接口函数</h3><ul><li>采用驼峰命名法（PascalCase）</li><li>示例：<code>ConfigUsart()</code>、<code>GetSystemState()</code></li></ul><h2 id="九、变量命名规范"><a href="#九、变量命名规范" class="headerlink" title="九、变量命名规范"></a>九、变量命名规范</h2><h3 id="变量前缀规范"><a href="#变量前缀规范" class="headerlink" title="变量前缀规范"></a>变量前缀规范</h3><table><thead><tr><th>类型</th><th>前缀</th><th>示例</th></tr></thead><tbody><tr><td>指针变量</td><td><code>p_</code></td><td><code>p_buffer</code></td></tr><tr><td>全局变量</td><td><code>g_</code></td><td><code>g_system_state</code></td></tr><tr><td>静态全局变量</td><td><code>s_</code></td><td><code>s_init_flag</code></td></tr><tr><td>布尔变量</td><td><code>is_</code>&#x2F;<code>has_</code>&#x2F;<code>can_</code></td><td><code>is_running</code>、<code>has_data</code></td></tr><tr><td>数组&#x2F;缓冲区</td><td><code>_buf</code> 或 <code>_arr</code> 后缀</td><td><code>tx_buf</code>、<code>data_arr</code></td></tr></tbody></table><h3 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h3><ul><li>采用下划线分隔法</li><li>以功能为开头</li><li>示例：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">bool</span> spk_action;<br>    <span class="hljs-type">uint8_t</span> spk_volume;<br>&#125; <span class="hljs-type">spk_event_t</span>;<br></code></pre></td></tr></table></figure><h3 id="变量大小优化（MCU资源有限）"><a href="#变量大小优化（MCU资源有限）" class="headerlink" title="变量大小优化（MCU资源有限）"></a>变量大小优化（MCU资源有限）</h3><table><thead><tr><th>数值范围</th><th>推荐类型</th></tr></thead><tbody><tr><td>0 ~ 255</td><td><code>uint8_t</code></td></tr><tr><td>0 ~ 65535</td><td><code>uint16_t</code></td></tr><tr><td>超过65535</td><td><code>uint32_t</code></td></tr><tr><td>带符号小范围</td><td><code>int8_t</code>、<code>int16_t</code></td></tr></tbody></table><h2 id="十、回调与中断命名"><a href="#十、回调与中断命名" class="headerlink" title="十、回调与中断命名"></a>十、回调与中断命名</h2><ul><li>回调函数：<code>xxx_callback()</code> 或 <code>xxx_cb()</code></li><li>中断处理：<code>XXX_IRQHandler()</code>（与厂商库保持一致）</li></ul><h2 id="十一、头文件规范"><a href="#十一、头文件规范" class="headerlink" title="十一、头文件规范"></a>十一、头文件规范</h2><h3 id="头文件保护宏"><a href="#头文件保护宏" class="headerlink" title="头文件保护宏"></a>头文件保护宏</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __MODULE_NAME_H__</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __MODULE_NAME_H__</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* __MODULE_NAME_H__ */</span></span><br></code></pre></td></tr></table></figure><h3 id="include顺序"><a href="#include顺序" class="headerlink" title="include顺序"></a>include顺序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 1. 标准库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><span class="hljs-comment">// 2. 芯片/HAL库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stm32f1xx.h&quot;</span></span><br><span class="hljs-comment">// 3. 第三方库</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fatfs.h&quot;</span></span><br><span class="hljs-comment">// 4. 自定义头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bsp_lcd.h&quot;</span></span><br></code></pre></td></tr></table></figure><h3 id="静态局部函数声明位置"><a href="#静态局部函数声明位置" class="headerlink" title="静态局部函数声明位置"></a>静态局部函数声明位置</h3><ul><li>静态局部函数声明放置在 <code>.h</code> 文件的<strong>最后面</strong></li></ul><h3 id="头文件注释规范"><a href="#头文件注释规范" class="headerlink" title="头文件注释规范"></a>头文件注释规范</h3><ul><li><strong>禁止</strong>在 <code>.h</code> 文件内使用 doxygen 注释</li><li>采用 <code>/* */</code> 或 <code>//</code> 简短介绍</li><li>示例：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 初始化LCD模块 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LcdInit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><br><span class="hljs-comment">// 设置LCD背光亮度</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LcdSetBacklight</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> level)</span>;<br></code></pre></td></tr></table></figure><h2 id="十二、模块状态枚举"><a href="#十二、模块状态枚举" class="headerlink" title="十二、模块状态枚举"></a>十二、模块状态枚举</h2><p>每个模块创建前需要增加一个 <code>enum</code> 状态来代表该模块的状态：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    MODULE_STATE_IDLE,<br>    MODULE_STATE_INIT,<br>    MODULE_STATE_RUNNING,<br>    MODULE_STATE_ERROR<br>&#125; module_state_enum;<br></code></pre></td></tr></table></figure><h2 id="十三、返回值与错误码规范"><a href="#十三、返回值与错误码规范" class="headerlink" title="十三、返回值与错误码规范"></a>十三、返回值与错误码规范</h2><h3 id="返回值约定"><a href="#返回值约定" class="headerlink" title="返回值约定"></a>返回值约定</h3><table><thead><tr><th>返回值</th><th>含义</th></tr></thead><tbody><tr><td><code>0</code></td><td>成功</td></tr><tr><td><code>-1</code> 或 负数</td><td>失败&#x2F;错误码</td></tr><tr><td><code>&gt; 0</code></td><td>数据长度或特定状态</td></tr></tbody></table><h3 id="模块错误码定义"><a href="#模块错误码定义" class="headerlink" title="模块错误码定义"></a>模块错误码定义</h3><p>每个模块定义独立的错误码枚举：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span><br>    MODULE_OK = <span class="hljs-number">0</span>,<br>    MODULE_ERR_PARAM,<br>    MODULE_ERR_TIMEOUT,<br>    MODULE_ERR_BUSY<br>&#125; module_err_enum;<br></code></pre></td></tr></table></figure><h2 id="十四、魔数处理"><a href="#十四、魔数处理" class="headerlink" title="十四、魔数处理"></a>十四、魔数处理</h2><ul><li><strong>禁止</strong>直接使用魔数，必须定义为宏或枚举</li><li>示例：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 错误示范</span><br><span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">256</span>) &#123; ... &#125;<br><br><span class="hljs-comment">// 正确示范</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_MAX_SIZE  256</span><br><span class="hljs-keyword">if</span> (count &gt; BUFFER_MAX_SIZE) &#123; ... &#125;<br></code></pre></td></tr></table></figure><h2 id="十五、代码生成规则（AI辅助开发）"><a href="#十五、代码生成规则（AI辅助开发）" class="headerlink" title="十五、代码生成规则（AI辅助开发）"></a>十五、代码生成规则（AI辅助开发）</h2><h3 id="结构体生成规则"><a href="#结构体生成规则" class="headerlink" title="结构体生成规则"></a>结构体生成规则</h3><ul><li>在生成模块的结构体前，<strong>必须</strong>与用户确认需要的内容后才能开始生成</li></ul><h3 id="模块代码生成流程"><a href="#模块代码生成流程" class="headerlink" title="模块代码生成流程"></a>模块代码生成流程</h3><ol><li><strong>禁止</strong>一次性生成 <code>.h</code> 和 <code>.c</code> 的完整实现</li><li>生成 <code>.h</code> 文件时，在 <code>.c</code> 文件内<strong>仅生成接口函数名</strong>（空函数体）</li><li><strong>等待用户确认</strong>后，才能生成函数具体实现</li></ol><p>示例流程：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs monkey"><span class="hljs-keyword">Step</span> <span class="hljs-number">1</span>: 生成 <span class="hljs-keyword">module</span>.h（完整声明）<br><span class="hljs-keyword">Step</span> <span class="hljs-number">2</span>: 生成 <span class="hljs-keyword">module</span>.c（仅函数框架，无实现）<br><span class="hljs-keyword">Step</span> <span class="hljs-number">3</span>: 用户确认<br><span class="hljs-keyword">Step</span> <span class="hljs-number">4</span>: 逐个生成函数实现<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
      <tag>代码规范</tag>
      
      <tag>架构设计</tag>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/12/01/hello-world/"/>
    <url>/2025/12/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
